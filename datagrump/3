#include <iostream>
#include <cmath>
#include <gsl/gsl_randist.h>
#include <boost/math/distributions/poisson.hpp>
#include "controller.hh"
#include "timestamp.hh"

#define DEBUGGING if (debug_)

using namespace std;

Controller::Controller(const bool debug)
  : debug_(true)
{
    double dr = 1000.0 / 256;
    rates = new double[n_rates];
    probs = new double[n_rates];
    for (int i = 0; i < n_rates; i++)
    {
        rates[i] = (i + 1) * dr;
        probs[i] = 1.0 / 256;
    }
}

unsigned int Controller::window_size()
{
    DEBUGGING
    {
        // cerr << "Window size: " << cur_ws << endl;
    }
    return cur_ws;
}

void Controller::datagram_was_sent(
		/* of the sent datagram */
        const uint64_t sequence_number,
        /* in milliseconds */
		const uint64_t send_timestamp)
{
    in_transit++;
}

long factorial(long x)
{
    long prod = 1;
    for (long i = 1; i <= x; i++)
    {
        prod *= i;
    }

    return prod;
}

// void Controller::evolve(secs)
// {
//     normal_distribution<double> dist(0, sqrt(secs) * vol);
//     for (int i = 0; i < n_rates; i++)
//     {
//         rates[i] += dist(gen);
//         if (rates[i] < 1000 / 256.0)
//         {
//             rates[i] = 1000 / 256.0;
//         }
//     }
// }

void Controller::ack_received(
        /* what sequence number was acknowledged */
        const uint64_t sequence_number_acked,
        /* when the acknowledged datagram was sent (sender's clock) */
        const uint64_t send_timestamp_acked,
        /* when the acknowledged datagram was received (receiver's clock)*/
        const uint64_t recv_timestamp_acked,
        /* when the ack was received (by sender) */
        const uint64_t timestamp_ack_received)
{
    in_transit--;
    if (start_time == 0)
    {
        start_time = recv_timestamp_acked;
    }

    ts_t time_elapsed = timestamp_ack_received - start_time;
    double secs = time_elapsed / 1000.0;
    num_acks++;

    if (time_elapsed > tick_length)
    {
        link_rate = 1000 * num_acks / (double) time_elapsed;
        start_time = timestamp_ack_received;

        double fs[n_rates];
        double f_sum = 0.0;
        normal_distribution<double> dist(0, sqrt(secs) * vol);
        for (int i = 0; i < n_rates; i++)
        {
            rates[i] += dist(gen);
            if (rates[i] < 1000 / 256.0)
            {
                rates[i] = 1000 / 256.0;
            }
            double p = boost::math::pdf(
                    boost::math::poisson(rates[i] * secs),
                    num_acks);
            fs[i] = probs[i] * p;
            f_sum += fs[i];
        }

        // double pred_rate = 0.0;
        for (int i = 0; i < n_rates; i++)
        {
            probs[i] = fs[i] / f_sum;
            // pred_rate += rates[i] * probs[i];
        }

        double forecast_rates[n_rates];
        for (int i = 0; i < n_rates; i++)
        {
            forecast_rates[i] = rates[i];
        }

        int new_ws = 0;
        int last_ws = 0;
        int queue_estimate = in_transit;
        for (int tick = 0; tick < 8; tick++)
        {
            normal_distribution<double> dist(0,
                    sqrt(tick_length / 1000.0) * vol);
            for (int i = 0; i < n_rates; i++)
            {
                forecast_rates[i] += dist(gen);
                if (forecast_rates[i] < 1000 / 256.0)
                {
                    forecast_rates[i] = 1000 / 256.0;
                }
            }

            double pred_rate = 0.0;
            for (int i = 0; i < n_rates; i++)
            {
                pred_rate += forecast_rates[i] * probs[i];
            }

            int expected_drain = boost::math::quantile(
                    boost::math::poisson(pred_rate * 100 * 0.001), 0.05);
            queue_estimate = max(queue_estimate - expected_drain, 0);
            int to_send = max(queue_estimate - expected_drain, 1);
            queue_estimate += (to_send - expected_drain);
            queue_estimate = max(queue_estimate, 1);
        }

        // cur_ws = new_ws;
        cur_ws = new_ws;
        // cur_ws = new_ws;

        // cout << pred_rate << ", " << link_rate << endl;
        // cur_ws = boost::math::quantile(
        //         boost::math::poisson(pred_rate * 0.1), 0.05) + 1;
        cout << cur_ws << endl;
        num_acks = 0;
    }
}

unsigned int Controller::timeout_ms()
{
    return 1000;
}
